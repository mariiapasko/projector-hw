// TASK 1

console.log('start');

const promise1 = new Promise((resolve, reject) => {
    console.log(1)
    resolve(2)
})

promise1.then(res => {
    console.log(res)
})

console.log('end');

//Result: start —> 1 —> end —> 2

//1. cпочатку виведе у консоль строку “start”, так як цей рядок у глобальному скоупі перший, а JS зчитує зверху вниз
//2. Консоль виведе 1. Оскільки спочатку створюється конструктор promise, що приймає function з двома аргументами. Оскільки це callback функція, то спочатку спрацює console.log(1), а потім вже promise змінює свій стан на fulfilled з аргументом 2, і додається у ланцюжок завдань для вирішення проміса. Далі викликається метод then() для обробки результату в promise1,
//3. Консоль виведе “end”, а оскільки функція  promise асинхронна, то спочатку отримаємо end, а потім вже 
//4. Число 2.


// TASK 2

Promise.resolve(1)
    .then((x) => x + 1)
    .then((x) => { throw new Error('My Error') })
    .catch(() => 1)
    .then((x) => x + 1)
    .then((x) => console.log(x))
    .catch(console.error)

//Result: 2

//1. Promise.resolve(1) Створюється обʼєкт promise з успішною обіцянкою resolve()
//2. Виклик першого метода then() і передача параметра х в callback функцію, що повертає х + 1. Тобто результатом буде 2.
//3. .then((x) => { throw new Error('My Error') }) Виклик другого метода then(), що показує помилку з повідомленням 'My Error’.
//4. .catch(() => 1) Цей метод обробляє попередню помилку і повертає значення 1 promisу.
//5. .then((x) => x + 1) Викликає знов метод then(). Результатом буде 2, оскільки замість х буде 1, що повернуте на попередньому виклику.
//6. .then((x) => console.log(x)) в консоль виводимо попередній виклик зі значенням 2.
//7. .catch(console.error) цей виклик без обробки, оскільки всі помилки були попередньо оброблені.


// TASK 3

const promise = new Promise(res => res(2));
promise.then(v => {
    console.log(v);
    return v * 2;
})
    .then(v => {
        console.log(v);
        return v * 2;
    })
    .finally(v => {
        console.log(v);
        return v * 2;
    })
    .then(v => {
        console.log(v);
    });

//Result: 8

//1. Створюється обʼєкт Promise, що одразу викликає функцію res з аргументом 2 та виконує цей promise.
//2. promise.then(v => Викликається метод .then() для обробки результату промісу, що був виконаний раніше. Консоль виводить 2, а потім повертає нове значення, що дорівнює 4. return v * 2 = 2 * 2.
//3. Викликається наступний метод .then(), де в консоль виводиться 4 з попереднього методу .then(), а потім повертає нове значення і отримуємо 8. return v * 2 = 4 * 2.
//4. Виконується метод .finally, де в консоль буде виведено 2(оскільки він виконується незалежно від попередніх операцій), а потім повернене нове значення 4 return v * 2 = 2 * 2.
//5.  Виконується метод .then(), де в консоль буде виведено результат з попереднього виклику then() - 8.



